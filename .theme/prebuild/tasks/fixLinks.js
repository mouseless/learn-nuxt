import { readFileSync, writeFileSync } from "fs";
import { join, parse } from "path";
import log from "./utils/log.js";
import files from "./utils/files.js";

/*
 * Fixes relative markdown links in given soruce directory
 * @async
 * @param {Object} parameters Task parameters
 * @param {String} parameters.source Source directory to process
 * @param {String} parameters.indexFile Index file name
 *
 * @returns {Promise}
 */
export default async function({ source, indexFile }) {
  log.info(`Fixing markdown links in '${source}'`);

  await files(source, ".md", async (dir, file) => {
    const sourceFile = join(source, dir, file);

    let data = readFileSync(sourceFile, "utf8");

    // this regex was generated by https://regex-generator.olafneumann.org/
    // to include new lines between markdown links
    const links = (data.match(/\[[^\]]*\]\([^)]*\)/gm) || [])
      // [name](./path/file.md) -> ./path/file.md
      .map(link => link.substring(link.indexOf("(") + 1, link.indexOf(")")))
      // exclude external links
      .filter(link => !link.startsWith("http://") && !link.startsWith("https://"))
      // parse links into path objects
      .map(link => { return { original: link, parsed: parse(link) }; })
      // exclude non md files
      .filter(link => link.parsed.ext.endsWith(".md"))
    ;

    if (links.length == 0) {
      log.debug(`${sourceFile} => no links found`, 1);
      return;
    }

    links.forEach(link => {
      // don't include extension
      let href = join(link.parsed.dir, link.parsed.name);
      if(link.original.endsWith(indexFile)) {
        // dont put index file name in path
        href = link.parsed.dir;

        if(href === "") {
          href = "/";
        }
      }

      data = data.replace(link.original, href);
      log.debug(`${sourceFile}: ${link.original} => ${href}`, 1);
    });

    writeFileSync(sourceFile, data);

    log.success(`${sourceFile} => ${links.length} link(s) fixed`, 1);
  });
}
