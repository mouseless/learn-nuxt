import{p as N,e as U,d8 as X,cl as W,d9 as S,da as x,ae as q,cp as z,db as I,co as J,i as B,X as G,dc as Q,cm as Y,x as Z,b as p,dd as K,q as A,n as k,c as T,a as l,d as w,t as C,F as aa,r as ea,o as E}from"#entry";const ta={trailing:!0};function sa(a,e=25,i={}){if(i={...ta,...i},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let o,t,r=[],s,u;const f=(n,v)=>(s=na(a,n,v),s.finally(()=>{if(s=null,i.trailing&&u&&!t){const D=f(n,u);return u=null,D}}),s),y=function(...n){return i.trailing&&(u=n),s||new Promise(v=>{const D=!t&&i.leading;clearTimeout(t),t=setTimeout(()=>{t=null;const d=i.leading?o:f(this,n);u=null;for(const b of r)b(d);r=[]},e),D?(o=f(this,n),v(o)):r.push(v)})},c=n=>{n&&(clearTimeout(n),t=null)};return y.isPending=()=>!!t,y.cancel=()=>{c(t),r=[],u=null},y.flush=()=>{if(c(t),!u||s)return;const n=u;return u=null,f(this,n)},y}async function na(a,e,i){return await a.apply(e,i)}const ra=Symbol.for("nuxt:client-only");function ia(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;oa(a[0],a[1])&&a.unshift(e);let[i,o,t={}]=a;const r=N(()=>J(i));if(typeof r.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof o!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const s=U();t.server??=!0,t.default??=la,t.getCachedData??=L,t.lazy??=!1,t.immediate??=!0,t.deep??=X.deep,t.dedupe??="cancel",t._functionName,s._asyncData[r.value];const u={cause:"initial",dedupe:t.dedupe};s._asyncData[r.value]?._init||(u.cachedData=t.getCachedData(r.value,s,{cause:"initial"}),s._asyncData[r.value]=H(s,r.value,o,t,u.cachedData));const f=s._asyncData[r.value];f._deps++;const y=()=>s._asyncData[r.value].execute(u),c=t.server!==!1&&s.payload.serverRendered;{let D=function(m){const _=s._asyncData[m];_?._deps&&(_._deps--,_._deps===0&&_?._off())};const d=W();if(d&&c&&t.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const m=d._nuxtOnBeforeMountCbs;S(()=>{m.forEach(_=>{_()}),m.splice(0,m.length)}),x(()=>m.splice(0,m.length))}const b=d&&(d._nuxtClientOnly||q(ra,!1));c&&s.isHydrating&&(f.error.value||f.data.value!==void 0)?f.status.value=f.error.value?"error":"success":d&&(!b&&s.payload.serverRendered&&s.isHydrating||t.lazy)&&t.immediate?d._nuxtOnBeforeMountCbs.push(y):t.immediate&&f.status.value!=="success"&&y();const h=K(),g=z(r,(m,_)=>{if((m||_)&&m!==_){const F=s._asyncData[_]?.data.value!==void 0,M=s._asyncDataPromises[_]!==void 0;_&&D(_);const j={cause:"initial",dedupe:t.dedupe};if(!s._asyncData[m]?._init){let P;_&&F?P=s._asyncData[_]?.data.value:(P=t.getCachedData(m,s,{cause:"initial"}),j.cachedData=P),s._asyncData[m]=H(s,m,o,t,P)}s._asyncData[m]._deps++,(t.immediate||F||M)&&s._asyncData[m].execute(j)}},{flush:"sync"}),R=t.watch?z(t.watch,()=>{f._execute({cause:"watch",dedupe:t.dedupe})}):()=>{};h&&I(()=>{g(),R(),D(r.value)})}const n={data:O(()=>s._asyncData[r.value]?.data),pending:O(()=>s._asyncData[r.value]?.pending),status:O(()=>s._asyncData[r.value]?.status),error:O(()=>s._asyncData[r.value]?.error),refresh:(...D)=>s._asyncData[r.value].execute(...D),execute:(...D)=>s._asyncData[r.value].execute(...D),clear:()=>$(s,r.value)},v=Promise.resolve(s._asyncDataPromises[r.value]).then(()=>n);return Object.assign(v,n),v}function O(a){return N({get(){return a()?.value},set(e){const i=a();i&&(i.value=e)}})}function oa(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}function $(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=p(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]&&(a._asyncDataPromises[e].cancelled=!0),a._asyncDataPromises[e]=void 0)}function ca(a,e){const i={};for(const o of e)i[o]=a[o];return i}function H(a,e,i,o,t){a.payload._errors[e]??=void 0;const r=o.getCachedData!==L,s=i,u=o.deep?B:G,f=t!==void 0,y=a.hook("app:data:refresh",async n=>{(!n||n.includes(e))&&await c.execute({cause:"refresh:hook"})}),c={data:u(f?t:o.default()),pending:N(()=>c.status.value==="pending"),error:Q(a.payload._errors,e),status:G("idle"),execute:(...n)=>{const[v,D=void 0]=n,d=v&&D===void 0&&typeof v=="object"?v:{};if(a._asyncDataPromises[e]){if((d.dedupe??o.dedupe)==="defer")return a._asyncDataPromises[e];a._asyncDataPromises[e].cancelled=!0}{const h="cachedData"in d?d.cachedData:o.getCachedData(e,a,{cause:d.cause??"refresh:manual"});if(h!==void 0)return a.payload.data[e]=c.data.value=h,c.error.value=void 0,c.status.value="success",Promise.resolve(h)}c.status.value="pending";const b=new Promise((h,g)=>{try{h(s(a))}catch(R){g(R)}}).then(async h=>{if(b.cancelled)return a._asyncDataPromises[e];let g=h;o.transform&&(g=await o.transform(h)),o.pick&&(g=ca(g,o.pick)),a.payload.data[e]=g,c.data.value=g,c.error.value=void 0,c.status.value="success"}).catch(h=>{if(b.cancelled)return a._asyncDataPromises[e];c.error.value=Z(h),c.data.value=p(o.default()),c.status.value="error"}).finally(()=>{b.cancelled||delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=b,a._asyncDataPromises[e]},_execute:sa((...n)=>c.execute(...n),0,{leading:!0}),_default:o.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{y(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),r||Y(()=>{a._asyncData[e]?._init||($(a,e),c.execute=()=>Promise.resolve())})}};return c}const la=()=>{},L=(a,e,i)=>{if(e.isHydrating)return e.payload.data[a];if(i.cause!=="refresh:manual"&&i.cause!=="refresh:hook")return e.static.data[a]};function ua(){const{public:{gitHubBaseURL:a}}=A();async function e(t){return await $fetch(`repos/${t}/stats/contributors`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function i(t){return await $fetch(`repos/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}async function o(t){return await $fetch(`orgs/${t}`,{baseURL:a,method:"GET",headers:{"X-GitHub-Api-Version":"2022-11-28"}})}return{getContributorStats:e,getRepository:i,getOrganization:o}}const da={class:"flex flex-wrap content-center justify-start items-center"},fa={class:"repository"},va={class:"flex flex-wrap content-center justify-start items-center"},ma={class:"p-sm text-center justify-start m-5"},_a=["src"],V="mouseless",Da={__name:"fetching-data",async setup(a){let e,i;const{getContributorStats:o,getRepository:t,getOrganization:r}=ua(),s=`${V}/learn-nuxt`,u=B([]),f=B(),{data:y}=([e,i]=k(async()=>ia("organization",async()=>await r(V))),e=await e,i(),e);return S(async()=>u.value=await t(s)),S(async()=>f.value=await o(s)),(c,n)=>(E(),T("div",da,[l("div",null,[n[3]||(n[3]=l("h2",null,"Fetch Once - Server or Client",-1)),l("div",null,[n[0]||(n[0]=l("strong",null,"Organization:",-1)),w(" "+C(p(y).name)+" ",1),n[1]||(n[1]=l("br",null,null,-1)),n[2]||(n[2]=l("strong",null,"Public repositories count:",-1)),w(" "+C(p(y).public_repos),1)])]),l("div",fa,[n[7]||(n[7]=l("h2",null,"Fetch Once - Only Client",-1)),l("div",null,[n[4]||(n[4]=l("strong",null,"Repository:",-1)),w(" "+C(p(u)?.name)+" ",1),n[5]||(n[5]=l("br",null,null,-1)),n[6]||(n[6]=l("strong",null,"Description:",-1)),w(" "+C(p(u)?.description),1)])]),l("div",null,[n[9]||(n[9]=l("h2",null,"Fetch Twice - Server and Client",-1)),l("div",va,[(E(!0),T(aa,null,ea(p(f),v=>(E(),T("div",{key:v.author.login},[l("div",ma,[l("img",{class:"w-24 h-24 rounded-sm mb-2",src:v.author.avatar_url},null,8,_a),l("h3",null,C(v.author.login),1),l("p",null,[n[8]||(n[8]=l("strong",null,"Total commits:",-1)),w(" "+C(v.total),1)])])]))),128))])])]))}};export{Da as default};
